Some values are not editable
  Examples:
    - user names, where they actually are user IDs, the label shows up in the input, not the actual value
    - when a value/facet is strict e.g. enumerated types should
    not be editable (it should act like a <select>)

 This has different implications depending on the mode you're in
   single:
    - when you enter a value, that becomes the value in the input

      - if you change the input value in any way what should happen?, should it delete the entire thing?
         - reset the value buyt not the input?
         - keep the same value until it is changed?
         - delete the entire (input) value?
      - if you type ANY key, should it also delete the entire thing and start over?

 Other problems with strict mode:
  - i want users to be able to type the thing, for example, state codes
    - do i do validations on the values if they don't select something?
  -

 ------

 more cans of worms

 - simply comparing the current against the input is not good enough if we are going to allow different values/labels
 - you would have to track the last selected value from the dropdown
  - this itself will have its own problems:
    - what if someone types in the value themselves?
      - do i do a search and compare against the results, and consider it selected if it is one of the values?
      - do i force them to select the value from the dropdown
      - common case, they paste the value that is valid
      - case insensitivity (yuck)
      - user might want to supply own (async) callback to determine if the value they entered manually is valid

  from a view perspective, what should it look like?
    - single mode:
      - when i type a value, and it is a userid/name pair. i need to show the name on the input, but have the value
        in the state. currentEntry or entries will work since it contains the proper data structure, but that doesn't
        me figure out what the value should be for the rendered input.

        - What if they try to change the value? They are not changing the value, but the label for the value.
        - Making the value atomic (all or nothing), would imply that i clear the value the moment they try to edit it.
        - Do i clear the value the moment the input value changes?
      - i think the only thing you can really do that is not extremely difficult to visually convey is to always clear the input

NOTES:

  options
    enabled/disabled (normal input vs autocomplete)
    onToggleMode(enable/disable)
    value = syncing is gonna be a bitch (must be tokenized and conerted to format)
    placeholder
    rewriter
    getDropdown
    getFacets
    getValues



  requirements:



    - single
      - entering values
      - deleting values
      - value shows up on in onChange


    - options
        - allow empty lookup
        - force to value from lookup

TRACK:

-- single
-- multiple
    - gains focus
    - entering text
    - deleting text
    - showing dropdown
    - calling lookup
    - populating value(s) in dropdown
    - set value
    - add value
    - remove value
    - delete entry
    - loses focus
    -


-- faceted
    - gains focus
    - entering text
    - paging through facets
    - selecting a facet
    - now have a facet candidate (single only)
    - operator?
    - select values
    - add/remove values
    - create entry
    - delege entry
    - select another facet/value(s) combo

Key Handlers:
    - escape: leaveContext
        - if in dropdown, go to input
        - if moving through facets, go to input
    - tab: context sensitive
        - if item selected in dropdown, select item
        - if no item selected in dropdown && permitted, set input as facet/value
        - if value is set or has no value, and on an entry, go forward
        - else lose focus
    - shift tab: context sensitive
        - if on an entry, but not first one, go to previous entry
        - else lose focus
    - home
        - if in dropdown, go to first entry
        - if in input, go to beginning of input
        - if in input and already at beginning, go to first entry
        - else do nothing
    - end
        - if in dropdown, go to last entry
        - if in input, go to end of input
        - if in input and already at end (in any editable entry), go to main input
        - else do nothing
    - shift home
    - shift end
    - right arrow
    - left arrow
    - down arrow
    - up arrow
    - ctrl+enter
    - delete
    - backspace
    - enter



- key events
- adding filters
- removing filters
- editing filters
- changing the input
- erasing the input
- resetting everything
- cancel facet entry
- adding or removing values from a facet
- selecting a facet
- having a facet candidate
- moving back and forth between facets
- selecting multiple facets
- capturing input from custom dropdown/dropdown items and entering that
- undo?
- redo?
- entering values between two facets
- top/bottom caption? allow custom dropdown, with {this.props.children} being the regular dropdown?

notes 1/28:

- come up with a NICE and agreeable way to hide the dropdown when needed, and NOT to hide it when it is. i remember this
being a huge pain with the first version

2/24:

isStandaloneValue
 - this determines if a facet is actually a standalone value
 - so it would be done when we are not selecting a facet, but entering a potential custom facet
  - do we block custom facets too?
 - i think in this case we can just do it right before the value is entered
 - i don't really have a direct method for entering a facet value directory
 - would be ideal to separate the setting of the facet to the setting of the values
  - one is 1tomany and the other is not
  -

  - TODO: allow custom facets!

2/26:

Review of what old one can do
- searchFacetsWhenEmpty
    - minLength as function
- searchValuesWhenEmpty
    - minLength = 0
- allowEmptySearch

- enterSubmitsFromDropdown
- suppressDropdownAfterSubmit
- resetFilters
    - must initialize store externally to do this
- input
    - must initialize store externally to do this
- searchValues
    - done
- searchFacets
    - done
- onSubmit
    - TODO
- assistedMode
    - TODO: react concern
- onToggleMode
    - TODO: react concern
- optionTemplate
    - TODO: react concern
- disableTab
    - TODO: react concern
- tabSubmits
    - TODO: react concern
- placeholder
    - done
- isFIlter
    - isStandaloneValue
- stringifyFilters
    - will not implement
- autoSelectFirst
    - done
- tokenizeInput
    - will not implement
- defaultFacet
    - use rewriteValue
- dropdown (getDropdown)
- valueRewriter
    - rewriteValue
-

dropdown notes:
    custom dropdown:
        - problem with the custom dropdown as of now is that i am unable to have full access to the width
        - i really just need complete access to it so i can do whatever i want with it.

TODO:
    state:
        - onSubmit
        - onChange
        - on*
        - event handlers need to be more sophisticated than just passing a callback!
            - addHandlers (ugh i know)
    react:
        -
        - option template
            - basically working
        - custom dropdown
            -
        - disableTab, tabSubmits
            - prefer global event handler
    usability:
        - make it easier to pre-instantiate values
        - make it easier to pull out values
        - make it easier to programattically set values
        - make it easier to programattically unset values

TODO: event handlers:
    - global state change
        - onUpdate
    - change
        - changeInput
        -
    - addFilter
    - removeFilter
    - dropdown

TODO tests:
    - manipulating state, testing react components from that
    - manipulating react components, testing store & react from that

--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------

3/11:

Review of where we're at:
  - Will not do:
    - assistedMode
    - onToggleMode
    - optionTemplate
    - disableTab
    - tabSubmits

  - Future Work:
    - custom dropdown header
    - custom dropdown footer?
    - operators
    - placeholder (based on mode)
      - react placeholder (to have styling)
      - in order to do this completely correctly, would have to do the span trick (ugh)
      - for version 1, use input[placeholder]
    - validation
      - i suppose i would have to have a validate() function for the input
      - need to figure out where the validation message would go

  - Complete:
    - focus nonsense

  - In Progress:

    Features:
      - event handling in general, on*
      - keyboard event handling externally


    Bugs / Inconsistencies:

    Tests:
      - TODO everything

    breakdown by mode:
      - general
        - DONE type names
        - DONE option templates
        - DONE custom dropdown
        - DONE promise-based getValues
        - DONE types
        - DONE minLength
        - DONE custom values
          - support AllowCustomValues interface
          - fixup how custom values are entered
          - could be done select2 style (separate "staging" input below main input)
          - currently just erasing value
        - TODO error messages?
          - getValues() error messages?
          - getFacets() error messages?
          - stylistic concerns, how to format
        - TODO: click to focus
        - DONE test: getting state values?
        - TODO event handlers (before dispatcher?)
        - TODO keyboard commands
      - syncing mode via props
         - TODO: proper setValue/state kind of methods for changing the state

      - single mode
        - DONE auto select
        - DONE: custom values
        - DONE: test: rewriting values
        - DONE custom menuitems

      - multiple mode (extends single mode features)
        - incl all of single mode features
        - TODO: edit values
          - using react autosize input
          - TODO: edit values in store (in a clean way)
          - TODO: moving between values using arrow keys
          - TODO: bringing up autocomplete
          - just gotta do it

      - faceted mode
        - DONE auto select first facet/value
        - custom facet fields
        - custom values
        - promise-based getFacets
        - TODO: pass event - standalone values that act as filters
        - TODO: edit facet values
        - TODO: bringing up dropdown
        - defaultfacet

    Other checks:
      - not searching multiple times for single events
        - keyboard
        - click
        - focus
        - etc

      - not rendering multiples for:
        - dropdown
        - menuitem
        - entries
        - input

    Other features not getting implemented here:
        - ui mode toggle
        - ontoggle mode
        - keyboard event manipulation: disableTab, tabsubmits
        - tokenize input

    RoadBlocks:
      - focusing inputs from the state container
        - imagine i have to delete an entry. how do i keep focus and redirect in somewhere from the state store?
        - right now i am unable to do that because no such state is being tracked in the store
        - i have two options
          - either track state through the activeEntry or some such
          - pass in <inputs> to the store and let it do it itself.
        - i am partial to the former and just let them do the focusing

TODO: bugs
  - custom dropdown, when backspacing out of filter, normal state dropdown list shows up in place of map briefly before closing

-------------------------------------------------------------------------
-------------------------------------------------------------------------
-------------------------------------------------------------------------
-------------------------------------------------------------------------
-------------------------------------------------------------------------

Reset on the notes:

# Major Work Remaining

## Events

- change
- select
- unselect
- removeFacet
- addFacet
- addValue
- removeValue
- beforeUnselect / onSelecting
- beforeUnselect / onUnselecting
- scroll
- dropdownOpen
- dropdownClose
- *keyboard events
- *mouse events

ideas:

- add event dispatcher
  - convert to batched updates, redux style?

-

## Initializing / Updating

Making it easy to initialize, update values programmatically

### props

- responding to prop changes
- locking to prop values

- changing configuration of the <AssistedSearch> throug hprops

- no matter how powerful it gets, i still want to be able to do this: (
    <AssistedSearch value={this.val} onChange={this.handleChange} getValues={this.getVals}/>
  )
  // ^ LOCKED to the prop value, how to deal with that in the state store!?

  solutions:
    - have a custom react component to abstract this away. you can still have the full power, but some convenience



- easy getters and setters
- props vs state
- is it even possible to make this a stateless component, like truly?


// once again, more notes!

7/22

value prop, what does it change? does it only change the input? or does it change the entries? i would say we need
separate values. perhaps for single value, it only the value itself.

setValue()

-- live update the mode (single/multi/faceted after mount via prop change)

// periodic test failure 7/29/2018 @ 2:19AM

FAILED TESTS:
  <AssistedSearch>
    controlled state
      Ã— changing the input
        HeadlessChrome 67.0.3396 (Windows 10.0.0)
      AssertionError: expected '' to equal 'hello'
          at _callee2$ (base/test/webpack:/test/VisualSearchTest.js:39:51)
          at tryCatch (base/test/webpack:/node_modules/babel-runtime/node_modules/regenerator-runtime/runtime.js:62:15)
          at Generator.invoke [as _invoke] (base/test/webpack:/node_modules/babel-runtime/node_modules/regenerator-runtime/runtime.js:296:1)
          at Generator.prototype.(anonymous function) [as next] (base/test/webpack:/node_modules/babel-runtime/node_modules/regenerator-runtime/runtime.js:114:1)
          at step (base/test/webpack:/node_modules/babel-runtime/helpers/asyncToGenerator.js:17:1)
          at base/test/webpack:/node_modules/babel-runtime/helpers/asyncToGenerator.js:28:1


--- having a bit of writers block here

It's clearly not finished, but for some reason, i can't figure out what to do next.

-- work on editing facets tomorrow
-- (DONE) when hovering and has active, only give outline (so active looks more prominent)


-- auto-selecting
  - this happens when the user is not allowed to enter a custom value
  - once the value is committed, text input becomes "select only", in other words, you can either select it, or delete it (backspace or del)
  - if the option for customValues (or however) is true, we force it to this mode until the value is deleted
    - once the value is deleted, it can have anything it wants, but a value must be committed for that value to stick around after blur

-- editing
  - i already have the autosize inputs in there, so now we just need to make them editable (if eligible) OTHERWISE make it autoselect

-- single value should just be the input itself, not the entries, so really, the input and entries are very similar to each other, differing mostly in the size of the input

INSIGHT: the input and entry input should be the same component!

<VS>
  <Entries>
    <Entry entry={SearchEntry|null}>
      SearchEntry && <Name/>
      <EntryInput onChange={...}/>
    </Entry>
    <EntryInput>
  </Entries>
  <Dropdown/>
</VS>

--

entered entry
head entry

Other possible features?
  - disabled : boolean?
  - isEditableEntry? / readonly
  - maxEntries?
  - canAddEntry?
  - isRemovableEntry?

store {
  input: string;
  entries: Entry[];
  dropdownItems:
}

<div>
  {entries}
  Input
  {dropdown}
</div>

arrow logic:

let p = selectionStart of current input
let i = 0-based index of current entry (entry could also be the main input)

if (p = 0 &&

------------------------
Got left and right arrow keys working for entries, get it working for main input!
-------------------------

8-26

The pain here is dealing with the input not being treated like an entry. should it though?
What is the entry really?
  An input
  Has a facet value potentially

two data binding
  input
    store always reflects input's focus state
    input's focus state always reflects store

    onFocus=set store value if needed
    componentDidUpdate=focus if needed


# New Checklist

Redescribe the state container:
  - focused
  - main input
    - value (synced)
    - focused state (synced)
  - dropdownitem[]
  - selectedDropdownItem
  - entry[]
    - facet
    - input
      - value (synced)
    - focused state (synced)
  - selectedEntries



## Modes

SINGLE

MULTIPLE

FACETED

Modes:

- Need to have a 'no results found' indicator
- when entries are selected, keypress changing a value should deselect them (can do this in the store?)

Notes from work:

Notes for visual search:
- SINGLE VALUE
    - we shouldn't have entries, just the input.
    let A = editable
    - if A, the value is placed in the input
    - if !A, the label gets placed in the input,
    - if !editable, the text is selected so if the user hits a key, the value gets erased
    - just listen for onChange since that captures paste as well

When on the input and it is SINGLE and NON_EDITABLE:
    if has a value and value equals selected vlaue, always force it to selected until the value is changed

When on the input and it is SINGLE and EDITABLE:
    user can do basically whatever they want


- Single, Has Value, Non-Editable. This is really the only case that we have to worry about with regards to editing.
- Need to implement that as well as i am pretty sure i only ever did the "all" selected version.
  - when [|    ], next left selects the entire entry, or [    |], next right selects entire entry
- I think i actually do have the logic for this, where the arrow keys will select the input
  - validate!

- MULTIPLE VALUE
  - Multiple, Entry, Non-Editable, for these we can just make it so you never get to the select the text but rather than the entire bubble, as if you were going between them


GROUPS?

- Groups would be annoying
  - I don't really want to mess w/ groups with the first API
  - Migration would probably be like toNewGroups(myData) or whatever until we finalize

- Would prefer composition?
  - would rather NOT do something like [{group:'a',...}] because  that leaves me to groups and sort the values
  - i think we could include an option for a non-selectable header
  - header implies non-selectable?
  - header = non-selectable (not quite disabled since it might have different styles), special formatting,
  - disabled = non-selectable

-- enter submitting is no longer closing the dropdown, gotta fix that

-- handling submit
Would like to store to do this
setSelection or something could have a parameter to pass submit, then the store would _dispatch the submit event to the component

--------------------
--------------------
--------------------
--------------------
--------------------
--------------------
--------------------
--------------------
--------------------
--------------------
--------------------
--------------------
--------------------
--------------------
--------------------
--------------------
--------------------


Complete and utter rewrite of the state store. Answering t

Okay. gotta talk about removeEntry. This is going to be annoying...

_removeEntries: (number[], bool)

1. Remove the entries from the list of entries, obviously
2. Set the new active entry

Cases:
2 = active
1 = selected
0 = not selected or active

00210 -> 010
00120 -> 010
11200 -> 10
21100 -> 10

the basic function is, go backwards if you can, else go forwards, reverse for when deleteForward is true


dropdown clearing/focusing:

tab / enter
entry /  main

tab & main: keep open, focus main
tab & entry: keep open, focus main
enter & main: close, focus main
enter & entry: close, focus main



Brief discussion about setEntryValue

setEntryValue does not have any support for:
    - isStandaloneValue
    - rewriteValue

- need a standard method to do those things, consider the variables, and return a valid entry
- needs to work for all three modes too

variables:
    - isStandalone
    - rewrite
    - mode
    - candidate facet
    - label?

Examples:
    - setEntryValue: setting the value of an entry (and its input)
        - for simplicity, facet entries cannot have their facet fields changed

        - if standalone, facets can be set

_getEntryValue

===============================

prop value/onChange:
    - Been a whirlwind
    - still need the ideal mix of prop/change handling
    - the more i do this, the more i think that the components don't need much of anything to do their work
    - in terms of componentWillReceiveProps, just the options stuff and then we're basically done?
    - the VisualSearch should be managing the change for the values
    - we have a disparity, entries between props/store not consistent, being silently changed improperly
    - ADD UNIT tests for onchange w/ custom values on single value input

quick discussion about the whole initialvalues/any values/values in general passed via props

What are the ways that i would want to pass the props?

string
string[]
{value, label}
string + {value,label}
string + string[]
string + string

- entries needs to support all the above, string, string[], {value, label}
- value (input) needs to support string, {value,label}
- um idea, just pass the values to visualsearch/store and let the store deal with it
- doyyyyyiiii, same answer every time



- setValueAndEntries(value, entries, silent)
    silent ? this.noChange(() => _setValue(value, entries)
- @action _setValue(value, entries)


<SingleValue
  value={value:'a', label:'xyz'}
  entries=['a', {value:'a'}]
/>

<MultiValue
  value='abc'
  entries=['a', 'b', 'c']
/>

<FacetedValue
  entries=[toFacetValue('a, 'b')},
/>


===========

Build/Dist Plan:
    For the i build, i would like to:
        - have a dist build
        - have a dist.min build (maybe)
        - have es build outputs (similar to react-bootstrap)

    Directory Structure:
        dist/react-assisted-search.js
        dist/react-assisted-search.min.js

        es/** (i guess output of src)
        index.js [entry]
          - components
            - SingleValue
            - MultiValue
            - FacetedValue
            - VisualSearch

          - store
            - VisualSearchStore

          - everything else would be referenced via files


Just putting down thoughts:
    - dist: do with webpack for now, to match storybook/webpack dev build
    - es: tsc?
    - lib: tsc?
    - research: using babel w/ babel-plugin-transform-typescript
    - research: generate single types.ts
    - read: react typescript from tslang
    - tsc would probably be a huge ass pain


Okay new structure for now

dist/
    css/*.css
    js/react-assisted-search.js
    js/react-assisted-search.min.js

es/
    index.js
    (+  other dist output)

=========================
=========================
=========================
 __  ___  _______  _______ .______           ___   .___________.   .______     ______   .___________.___________.  ______   .___  ___.
|  |/  / |   ____||   ____||   _  \         /   \  |           |   |   _  \   /  __  \  |           |           | /  __  \  |   \/   |
|  '  /  |  |__   |  |__   |  |_)  |       /  ^  \ `---|  |----`   |  |_)  | |  |  |  | `---|  |----`---|  |----`|  |  |  | |  \  /  |
|    <   |   __|  |   __|  |   ___/       /  /_\  \    |  |        |   _  <  |  |  |  |     |  |        |  |     |  |  |  | |  |\/|  |
|  .  \  |  |____ |  |____ |  |          /  _____  \   |  |        |  |_)  | |  `--'  |     |  |        |  |     |  `--'  | |  |  |  |
|__|\__\ |_______||_______|| _|         /__/     \__\  |__|        |______/   \______/      |__|        |__|      \______/  |__|  |__|

=========================
=========================
=========================

NOTES/ISSUES:

BUGS:
  - onAll triggers infinite loop, probably only a good idea to do onAll with actual events
  - when autoSelectFirst is on, it can interfere with home/end
      - need a way to tell component that a value has been entered already?
  - do not show dropdown when a value has been committed (also in single mode)? and focusing to it
  - tab not setting filter value (should it always do that on faceted/multiple?

PERFORMANCE:
  - try to optimize the action code (lots of callbacks/arrow functions to make that happen, kinda eww, messes up stack)

CONSIDER:
  - (FIXED) prop values, labels? should we merge or always override?
  - tabSubmits? use event handler?

FEATURES:
  - customDropdown should not just override getValues/Facets
  - variable width dropdown is not done yet.
  - rewriteValue, do we need to worry about entries? (insert facet value?)

EASE OF USE:
  - (FIXED) entries should probably be arg[1] on onChange evt now, move store to arg[2]
  - consider shift+delete to delete previous entry? (or maybe just ctrl+delete hmmm)
  - (NOFIX) add style parameter?

FIXED/OBE:
  - need to finish implementing tabs
  - (FIXED) dropup NOT functioning properly, is switching on menu item change
  - (FIXED) repeated backspace, sometimes it deletes text, other just the entries
  - (FIXED) single, we reached this point where this is causing problems
      - setInput vs setValue, we need to change the entryValue
  - (FIXED) word completion / partial= true?
  - (FIXED) single value, setinput not changing entry!
  - (FIXED) Remove source maps from es build
  - (FIXED) certain actions not working when data binding is in effect
  - (FIXED) potentially could add factory auto data bind new values

=========================

the component performs a faceted search of fields using autocomplete to make search easier to do
you don't have to think about the field names or the values because it will bring them up for you

react-assisted-search